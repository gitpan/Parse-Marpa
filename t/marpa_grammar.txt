semantics are perl5.
the start symbol is grammar.

comment: I need to implement preamble code.
a preamble is q{
    use 5.9.5;
    use strict;
    use warnings;
    use Parse::Marpa;

    my $terminals = [];
    my $rules = [];

    sub canonical_symbol_name {
	my $symbol = lc shift;
	$symbol =~ s/[-_\s]+/-/g;
	$symbol;
    }
}.

the default lex prefix is qr/[ \t]*(\#[^\n]*\n|\n)?([ \t]*\#[^\n]*\n)*[ \t]*/.

concatenate lines is q{
    my $v_count = scalar @$Parse::Marpa::This::v;
    return undef if $v_count <= 0;
    join("\n", grep { $_ } @$Parse::Marpa::This::v);
}.
concatenate lines is the default action. # perl5 style comment

a preamble is q{

    our $default_lex_prefix = qr/[ \t]*(\#[^\n]*\n|\n)?([ \t]*\#[^\n]*\n)*[ \t]*/;

    sub canonical_symbol_name {
	my $symbol = lc shift;
	$symbol =~ s/[-_\s]+/-/g;
	$symbol;
    }
}.



grammar: paragraph break separated paragraph sequence.
         q{
	    q{
		use 5.9.5;
		use strict;
		use warnings;
		use Parse::Marpa;

		sub canonical_symbol_name {
		    my $symbol = lc shift;
		    $symbol =~ s/[-_\s]+/-/g;
		    $symbol;
		}

		my $terminals = [];
		my $rules = [];
	    }
	    . join("\n", grep { $_ } @$Parse::Marpa::This::v)
	    . "\n"
	    .q{
		my $g = new Parse::Marpa(
		    start => canonical_symbol_name("grammar"),
		    rules => $rules,
		    terminals => $terminals,
		    default_lex_prefix => $default_lex_prefix,
		);

		my $parse = new Parse::Marpa::Parse(
		   grammar=> $g,
		);
	    }
	   }.

# change definition to another word?
paragraph: definition paragraph. concatenate lines.

paragraph: production paragraph. concatenate_lines.

paragraph: terminal paragraph.  concatenate lines.

definition paragraph: definition sequence.  concatenate lines.

production paragraph:
	 non structural production sentences,
         production sentence,
	 non structural production sentences,
         optional action sentence,
	 non structural production sentences.
	concatenate lines.

non structural production sentences: optional non structural production sentence sequence.
concatenate lines.

action sentence: optional the keyword, "action", "is", action specifier, period. concatenate lines.

action sentence: action specifier, period. concatenate lines.

the keyword: "the". concatenate lines.

action specifier: string.  concatenate lines.

action specifier: symbol phrase.  concatenate lines.

non-structural production sentence: comment sentence. concatenate_lines.

non-structural terminal sentence: comment sentence.  concatenate lines.

definition: setting, period.  concatenate lines.

definition: preamble keyword, string, period.  concatenate lines.

definition: comment sentence.  concatenate lines.

definition: bracketed comment.  concatenate lines.

definition: string definition.  concatenate lines.

definition: default action definition.  concatenate lines.

setting: semantics setting.  concatenate lines.

setting: start symbol setting.  concatenate lines.

setting: default lex prefix setting.  concatenate lines.

semantics setting: optional the keyword, semantics keyword, copula, perl5 keyword.
concatenate lines.

semantics setting: perl5 keyword, copula, optional the keyword, semantics keyword.
concatenate lines.

start symbol setting:
optional the keyword, start keyword, symbol keyword, copula, symbol phrase.
concatenate lines.

start symbol setting: symbol phrase, copula, optional the keyword, start keyword, symbol keyword, 
concatenate lines.

default lex prefix setting: regex, copula, optional the keyword, default keyword, 
lex keyword, prefix keyword. 
concatenate lines.

default lex prefix setting:
optional the keyword,
default keyword, 
lex keyword, 
prefix keyword, 
copula,
regex.
concatenate lines.

copula: is keyword.  concatenate lines.

copula: are keyword.  concatenate lines.

string definition: define keyword, optional the keyword, action
keyword, symbol phrase, as keyword, string, period.  concatenate
lines.

default action definition: symbol phrase, is keyword, optional
the-keyword, default keyword, action keyword, period.  concatenate
lines.

comment sentence: comment tag, colon, optional comment word sequence, period.  discard.

string: q string.  concatenate lines.

string: double quoted string.  concatenate lines.

string: single quoted string.  concatenate lines.

pod block: pod head, pod body, pod cut.

pod body: optional pod line sequence.

production sentence: lhs, colon, rhs, period.
q{
'push(@$rules, '
. "{\n"
. join(",\n", @{$Parse::Marpa::This::v}[0,2])
. "\n});" 
}.

symbol phrase: symbol word sequence.
q{ q{"} . ::canonical_symbol_name(join("-", @$Parse::Marpa::This::v)) . q{"} }.

lhs: symbol phrase.
q{ "    lhs => " . join("-", @$Parse::Marpa::This::v) }.

rhs: rhs element sequence.
q{ "    rhs => [" . join(", ", @$Parse::Marpa::This::v) . "]" }.

rhs: comma separated rhs element sequence.
q{ "    rhs => [" . join(", ", @$Parse::Marpa::This::v) . "]" }.

rhs element: symbol phrase.  concatenate lines.

rhs element: string.  concatenate lines.

terminal paragraph:
non structural terminal sentence sequence,
terminal sentence,
non structural terminal sentence sequence.
concatenate lines.

terminal sentence: symbol phrase, matches keyword, regex, period.
q{
'{ my $regex_string = '
. $Parse::Marpa::This::v->[2]
. ";\n"
. 'push(@$terminals, '
. '[ '
. $Parse::Marpa::This::v->[0]
. ' => [ qr/$regex_string/ ] ]);'
. "\n}"
}.

action keyword matches qr/action/.

as keyword matches qr/as/.

are keyword matches qr/are/.

default keyword matches qr/default/.

define keyword matches qr/define/.

is keyword matches qr/is/.

lex keyword matches qr/lex/.

matches keyword matches qr/matches/.

perl5 keyword matches qr/perl5/.

preamble keyword matches qr/preamble/.

prefix keyword matches qr/prefix/.

semantics keyword matches qr/semantics/.

start keyword matches qr/start/.

symbol keyword matches qr/symbol/.

the keyword matches qr/the/.

match q string using qstring.

match regex using regex.

paragraph break matches qr/^[ \t]*\n\s*/m.

bracketed comment matches qr/\x{5b}[^\x{5d}]*\x{5d}/.

# change to lex_q_quote
# hex 5c is backslash
match single quoted string using q{
	    state $prefix_regex = qr/\G$main::default_lex_prefix'/o;
	    return unless $$STRING =~ /$prefix_regex/g;
            state $regex = qr/\G[^'\x{5c}]*('|\x{5c}')/;
	    MATCH: while ($$STRING =~ /$regex/gc) {
		next MATCH unless defined $1;
		if ($1 eq q{'}) {
		    my $length = (pos $$STRING) - $START;
		    return (substr($$STRING, $START, $length), $length);
		}
	    }
	    return;
        }.

match double quoted string using q{
	    # say "pos STRING=", (pos $$STRING), "; ", substr($$STRING, (pos $$STRING), 10);
	    state $prefix_regex = qr/\G$main::default_lex_prefix"/o;
	    return unless $$STRING =~ /$prefix_regex/g;
            state $regex = qr/\G[^"\x{5c}]*("|\x{5c}")/;
	    MATCH: while ($$STRING =~ /$regex/gc) {
		next MATCH unless defined $1;
		if ($1 eq q{"}) {
		    my $length = (pos $$STRING) - $START;
		    return (substr($$STRING, $START, $length), $length);
		}
	    }
	    return;
        }.

pod head matches qr/^=[a-zA-Z_].*$/m.

pod cut matches qr/^=cut.*$/m.

pod line matches qr/.*\n/m.

comment matches qr/#.*\n/.

symbol word matches qr/[a-zA-Z_][a-zA-Z0-9_-]*/.

period matches qr/\./.

colon matches qr/\:/.

# Do I want to allow comments between "to" and "do" ?
comment tag matches qr/(to\s+do|note|comment)/.

# Includes all non-whitespace printable characters except period
comment word matches qr/[\x{21}-\x{2d}\x{2f}-\x{7e}]+/.

comma matches qr/\,/.

whitespace matches qr/\s+/.

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:
