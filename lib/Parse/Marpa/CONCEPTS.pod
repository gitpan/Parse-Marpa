=head1 NAME

Parse::Marpa::CONCEPTS - Concepts helpful for Using Marpa

=head1 BEWARE: THIS DOCUMENT IS UNDER CONSTRUCTION AND VERY INCOMPLETE

    THIS DOCUMENT IS UNDER CONSTRUCTION AND VERY INCOMPLETE

=head1 OVERVIEW

This document is about practical concepts,
concepts for actually putting Marpa to work in your applications.
It's not about the mathematics or the parsing theory behind Marpa.
That's documented L<elsewhere|Parse::Marpa::ALGORITHM>.

It's also not a tutorial on grammars or BNF.  For that consult
a modern textbook, such as Grune and Jacobs I<Parsing Techniques -
Second Edition>, or Wikipedia.  In Wikipedia, the article on
I<Backus-Naur form> is a good place to start.

Only concepts common to all of Marpa's grammar interfaces
are covered.
Speaking of which ...

=head1 GRAMMAR INTERFACES

A grammar is specified to Marpa through a B<grammar interface>,
which may itself be described by Marpa grammar.
Right now there are only two grammar interfaces:
the B<Marpa Demonstration Language>
and the B<raw grammar interface>.

=head2 The Raw Grammar Interface

The B<raw grammar interface> is a set of options to the constructor for
Marpa grammar objects, C<Parse::Marpa::new()>.
All the other grammar interfaces will need to use the raw grammar interface indirectly.
It is efficient, but for most situations
users will want something higher level.
The documentation for the raw grammar interface
(as yet unwritten) is at  L<Parse::Marpa::RAW>.

=head2 The Marpa Demonstration Language

In Marpa's eyes all
higher level grammar interfaces will
be equal.
I call the one that I am delivering with 
Marpa the B<Marpa Demonstration Language> instead
of the "Marpa Language" to emphasize that it is not
intended to have special status.
Its documentation is at L<Parse::Marpa::LANGUAGE>.

=head2 Your Grammar Interface Here

Users are not only allowed to design their own
Marpa interfaces, I hope they feel enticed to do so.

=head1 TOKENS AND EARLEMES

As a reminder,
the standard method of parsing is to first break the text up into tokens.
Typically tokens are recognized with
as regular expressions or something similar.
The actual parsing is done on a sequence of tokens.
In Earley parsing, there is one "earley set" per token.

Marpa allows ambiguous tokens.  Marpa tokens allows recognition, at a single location,
of several different tokens of varying length.  Tokens may fall into arbitrary patterns.
For example, they can overlap.

What is considered a "location" is entirely up to the user.
There are only two restrictions:

=over 4

=item 1

Tokens cannot be zero or negative in length.

=item 2

Tokens must be grouped into "locations" called "earlemes".
and must be scanned in order.
That is, all the tokens at earleme C<N>
must be recognized before any tokens at the earleme <N+1>.

=back

A parse is said to start at earleme 0, and "earleme N" means the location C<N> earlemes
after earleme 0.
(Aside to experts: the implementation uses one earley set for each earleme.)
I also refer to "distances" in earlemes and lengths in earlemes,
and my meaning when I do is probably what you'd expect.
The length from earleme 3 to earleme 6,
for instance, is 3 earlemes.

The standard model of Earley parsing corresponds to a situation where there is one
earleme per token.  Marpa's C<Parse::Marpa::Parse::text()> method uses a model where
there's one earleme per character.  That is,
C<text()> lexes the input string for the user, 
and feeds lexed substrings as tokens to Marpa, giving as their earleme length their length
in characters.

In standard Earley parsing, a "location" without a token means the parse is exhausted.
In Marpa, tokens can span many earlemes.
A parse is viable as long as some token
has been recognized which ends at or after the current earleme.
Only when there is no token at the current location, and no token reaches to the current
location or past it, is the parse exhausted.
Parses using the grammar for the Marpa Demonstration Language typically contain many stretches
of empty earlemes, some quite long.
(Experts: an "empty earleme" corresponds to an Earley set with no Earley items.)

Users of Marpa are not restricted to either the one-token-per-earleme or the one-character-per-earleme
schemes.
Input tokens may be fed directly to Marpa with the C<Parse::Marpa::Parse::earleme()> method
and a user may supply earleme lengths according to any rules he finds useful, subject to
the two restrictions above.

=head1 THE STEPS OF MARPA PARSING

In parsing a text, Marpa follows a strict sequence, although much of it
is hidden from the user.
For example, when a parse object is created from a grammar
which has not been precomputed, the parse object constructor
will silently perform not just the precomputation of the grammar,
but also a deep copy of it.
In fact, if the C<Parse::Marpa::marpa()> routine is used,
the entire sequence below will be performed automatically
and none of the methods listed below need be called directly.
 
In each step listed, the B<lowest level method> performing it is mentioned.
Calling these methods in this sequence will rarely be the best approach.
For example, calling C<Parse::Marpa::precompute()> directly is rarely necessary
and clutters the code.
See the main L<Parse::Marpa> documentation page for
pointers to the easiest interfaces,
and ways to exercise greater control when that is desired.
Also see the detailed documentation for each method for hints as to
when it is best used.

=over 4

=item * Creation of a grammar object

A grammar object is created with C<Parse::Marpa::new()>.
although it may called indirectly.

=item * Adding rules to the grammar object

Rules must added to the grammar object.
This is done using the interfaces, and the raw
interface is always involved.
The raw interface may be called directly,
or it may be hidden behind a higher level interface.
At the lowest level, rules are added with the
C<Parse::Marpa::new()> and the C<Parse::Marpa::set()> methods.

=item * Precomputing the grammar object

Before a parse object can be created,
Marpa must do a series of precomputations on the grammar.
This step rarely needs to be performed explicitly, but when that is
necessary, the method call is C<Parse::Marpa::precompute>.

=item * Deep copying the grammar

Marpa parse objects work with a copy of the grammar, so that
multiple parses may go on at once.
The deep copying is done by writing the grammar out with C<Data::Dumper>,
then eval'ing the result and tweaking it.

These two subphases are available to the user as
C<Parse::Marpa::compile()> and C<Parse::Marpa::decompile()>.
The result of C<compile()> is a string, which may be written into a file.
A subsequent Marpa process may read this file and continue the parse.
See the descriptions of
C<Parse::Marpa::compile()> and C<Parse::Marpa::decompile()> for
more details.

=item * Creating the parse object

To parse a text, a parse object must be created.
The constructor C<Parse::Marpa::Parse::new()> is always called
to do this, whether directly or indirectly.
Strings and options specifying semantics may have been set in earlier phases,
but it is only now that the semantics are determined.
After this point they cannot change.

=item * Token Input

A series of tokens is input to the parse object,
and recognition is performed as the input is received.
Marpa, therefore, will eventually be
capable of on-line or stream processing.

If Marpa's input is structured in the same way as conventional
parsers, the input is recognized and ready to be evaluated
when at the same time a conventional on-line parser would be ready.
Marpa can deal with ambiguous,
variable length, and even overlapping tokens,
and the question of
when the user can expect these input tokens to be
recognized and ready to be evaluated as
part of a parse
is more complicated than with other parsers.
See elsewhere in this document, under "Earlemes and Tokens".

Currently input may be specified as text,
with the C<Parse::Marpa::Parse::text()> method or directly as tokens
with the C<Parse::Marpa::Parse::earleme()> method.

=item * Initial Parse Evaluation

Once the input is recognized, it can be evaluated.
The first value is computed with the C<Parse::Marpa::Parse::initial()> method.
C<initial()'s> return value is to indicate success or failure.
The value of the parse is accessible with the C<Parse::Marpa::Parse::value()> method.

=item * Parse Iteration

In Marpa a token sequence can have more than one parse.
These are iterated through with the
C<Parse::Marpa::Parse::next()> method
and values are retrieved with
C<Parse::Marpa::Parse::value()> method.

=back
