=head1 NAME

Parse::Marpa::Doc::Diagnostics - Diagnostics

=head1 DESCRIPTION

This document describes the techniques for debugging Marpa parses and grammars
and describes the Marpa methods and options whose main use is
tracing and debugging.

=head2 Basic Debugging Techniques

First look at the place where the parse was exhausted.
That, along with inspection of the input and the grammar,
is often enough to spot the problem.
Typically you'll have tried that already before consulting this
document.
You probably also already have
Marpa's C<warnings> option turned on (it's on by default),
but if not, you probably should.

When a problem is not obvious,
the first thing I do is turn on the C<trace_lex> option.
This tells you which tokens the lexer is looking for and which ones it thinks it found.
If the problem is in lexing, C<trace_lex> tells you the whole story.
Even if the problem is in the grammar,
which tokens the lexer is looking for is a clue to what the recognizer is doing.
That is because Marpa uses predictive lexing
and only looks for tokens that will result in a successful parse according
to the grammar.

It sometimes helps to look carefully at the output of
C<show_rules> and C<show_symbols>,
to check if anything there is
clearly not right or not what you expected.

If you're getting far enough to be able to return parse values from
C<Parse::Marpa::Evaluator::next> method,
but something is still wrong,
it can help to run the
C<Parse::Marpa::Evaluator::show> method after the call to C<next>.
The C<show> method returns the parse derivation.

=head2 Advanced Techniques

Next, depending on where in the process you're having problems,
you might want to
turn on some of the more helpful traces.
C<trace_actions> will show you the actions as they are being finalized.
In an ambiguous parse,
C<trace_evaluation_choices> shows the choices Marpa is making.
C<trace_iteration_changes> and C<trace_rules> traces the initialization of, and changes in, node values.

The above should be enough to enable you to spot any problem in writing a grammar.
But if you are interested in doing a complete investigation of a parse,
do the following:

=over 4

=item * Run C<show_symbols> on the precomputed grammar.

=item * Run C<show_rules> on the precomputed grammar.

=item * Run C<show_SDFA> on the precomputed grammar.

=item * Turn on C<trace_lex> before input.

=item * Run C<show_status> on the recognizer.

=item * Run C<show> on the evaluator.

=back

Note that when the input text to the grammar is of any length,
the output from C<show_status> and C<trace_lex> can be large.
You'll want to work with short inputs if at all possible.
The L<internals document|Parse::Marpa::Doc::Internals>
has example outputs from the C<show_SDFA> and C<show_status> methods,
and explains how to read them.

=head1 OPTIONS

These are Marpa options.
Unless otherwise stated,
these Marpa options are valid
for all methods which accept Marpa options as named arguments
(
C<Parse::Marpa::mdl>,
C<Parse::Marpa::Grammar::new>,
C<Parse::Marpa::Grammar::set>,
and
C<Parse::Marpa::Recognizer::new>),
and are useful at any point in the parse.
Trace output goes to the trace file handle.

=over 4

=item academic

The academic option turns off all grammar rewriting.
The resulting grammar is useless for recognition and parsing.
The purpose of the C<academic> argument is allow testing that Marpa's precomputations
can accurately duplicate examples from textbooks.
This is handy for testing the internals.
An exception is thrown if the user attempts to create
a recognizer from a grammar marked academic.
The C<academic> option
cannot be set in the recognizer or after the grammar is precomputed.

=item trace_actions

Traces actions as they are compiled.
Little or no knowledge of Marpa internals required.
This option is useless once the recognizer has been created.
Setting it after that point will result in a warning.

=begin undocumented:

# =item trace_completions

# Traces each Earley set as it is completed.
# May be set at any point.

#   Add warning if set after recognition?

# I find it better to wait until evaluation time,
# when there's more information
# and then use C<Parse::Marpa::Recognizer::show_status()>.
# Requires knowledge of Marpa internals.

=end undocumented:

=item trace_evaluation_choices

This option traces the non-trivial choices Marpa makes
among rules, among links, or among tokens.
A choice is non-trivial when there is more than one alternative.
Non-trivial choices only occur if the grammar is ambiguous.
Knowledge of Marpa internals probably needed.
May usefully be set at any point in the parse.

=item trace_iteration_changes

Traces setting of, and changes in, node values
during parse evaluation.
Knowledge of Marpa internals very useful.
May usefully be set at any point in the parse.

=item trace_iteration_searches

Traces Marpa's search through the Earley items
during parse evaluation.
Requires knowledge of Marpa internals.
May usefully be set at any point in the parse,
but probably only useful in combination with C<trace_iteration_changes>.
C<trace_iterations> turns on both.

=item trace_iterations

A short hand for setting both 
C<trace_iteration_changes> and
C<trace_iteration_searches>.
May usefully be set at any point in the parse.

=item trace_lex

A short hand for setting both 
C<trace_lex_matches> and
C<trace_lex_tries>.
Very useful, and can be interpreted with limited knowledge of Marpa internals.
Because Marpa uses predictive lexing,
this can give you an idea not only of how lexing is working,
but also of what the recognizer is looking for.
May be set at any point in the parse, but will be useless if
set after input is complete.

=item trace_lex_matches

Traces every successful match in lexing.
Can be interpreted with little knowledge of Marpa internals.
May be set at any point in the parse, but will be useless if
set after input is complete.

=item trace_lex_tries

Traces every attempted match in lexing.
Can be interpreted with little knowledge of Marpa internals.
Usually not useful without C<trace_lex_matches>.
C<trace_lex> turns on both.
May be set at any point in the parse, but will be useless if
set after input is complete.

=item trace_priorities

Traces the priority setting of each SDFA state.
Requires knowledge of Marpa internals.
These priorities are set when the recognizer is created.
A trace message warns the user if he sets
C<trace_priorities> after that point.

=item trace_rules

Traces rules as they are added to the grammar.
Useful, but you may prefer the C<show_rules()> method.
Doesn't require knowledge of Marpa internals.

A trace message warns the user if he sets this option
when rules have already been added.
If a user adds rules using the C<source> named argument,
and uses the C<trace_rules> named argument in the same call,
it will take effect B<after> the processing of the C<source> option,
which is probably not what he intended.
To be effective
C<trace_rules> must be set
in a method call prior to the one with the C<source> option.

=item trace_values

As each node value is set, prints a trace of the rule and the value.
Very helpful and does not require knowledge of Marpa internals.
May usefully be set at any point.

=back

=head1 METHODS

=head2 Static Method

=head3 show_location

   my $recce = new Parse::Marpa::Recognizer( { grammar => $grammar } );
    if ( ( my $fail_location = $recce->text( \$text_to_parse ) ) >= 0 ) {
        print STDERR Parse::Marpa::show_location( "Parse failed",
            \$text_to_parse, $fail_location );
        exit 1;             
    }                       

A utility routine helpful in formatting messages about problems parsing
user supplied text.
Takes three arguments, all required.
The first, I<message> argument, must be a string.
The second, I<text> argument, must be a reference to a string.
The third, I<offset> argument, must be an integer,
and will be interpreted as a character offset within that string.

C<show_location> returns a multi-line string with a header
line containing the I<message>,
followed by the line from I<text> which contains I<offset>,
followed by a line using the
ASCII "caret" symbol to point to the exact offset.

=head2 Grammar Methods

=head3 inaccessible_symbols

    $grammar = new Parse::Marpa::Grammar( { mdl_source => \$grammar_source } );
    $grammar->precompute();
    for my $symbol (@{$grammar->inaccessible_symbols()}) {
       say "Inaccessible symbol: ", $symbol;
    }

Returns the
plumbing names of the
inaccessible symbols.
Not useful before the grammar is precomputed.
Used for test scripts.
For debugging and tracing,
the warnings option is usually the most convenient
way to obtain the same information.

=head3 show_NFA

    $grammar = new Parse::Marpa::Grammar( { mdl_source => \$grammar_source } );
    $grammar->precompute();
    print $grammar->show_NFA();

Returns a multi-line string listing the states of the NFA
with the LR(0) items and transitions for each.
Not useful before the grammar is precomputed.
Not really helpful for debugging grammars
and requires very deep knowledge of Marpa internals.

=head3 show_SDFA

    $grammar = new Parse::Marpa::Grammar( { mdl_source => \$grammar_source } );
    $grammar->precompute();
    print $grammar->show_SDFA();

Returns a multi-line string listing the states of the SDFA
with the LR(0) items, NFA states, and transitions for each.
Not useful before the grammar is precomputed.
Very useful in debugging, but requires knowledge of Marpa internals.

=head3 show_accessible_symbols

    $grammar = new Parse::Marpa::Grammar( { mdl_source => \$grammar_source } );
    $grammar->precompute();
    say "Accessible symbols: ", $grammar->show_accessible_symbols();

Returns a one-line string with the plumbing names
of the accessible symbols of the grammar,
space-separated.
Useful in test scripts.
Not useful before the grammar is precomputed.
Not very useful for debugging.

=head3 show_nullable_symbols

    $grammar = new Parse::Marpa::Grammar( { mdl_source => \$grammar_source } );
    $grammar->precompute();
    say "Nullable symbols: ", $grammar->show_nullable_symbols();

Returns a one-line string with the plumbing names
of the nullable symbols of the grammar,
space-separated.
Useful in test scripts.
Not useful before the grammar is precomputed.
Not very useful for debugging.

=head3 show_nulling_symbols

    $grammar = new Parse::Marpa::Grammar( { mdl_source => \$grammar_source } );
    $grammar->precompute();
    say "Nulling symbols: ", $grammar->show_nulling_symbols();

Returns a one-line string with the plumbing names
of the nulling symbols of the grammar,
space-separated.
Useful in test scripts.
Not useful before the grammar is precomputed.
Not very useful for debugging.

=head3 show_problems

    $grammar = new Parse::Marpa::Grammar( { mdl_source => \$grammar_source } );
    $grammar->precompute();
    print $grammar->show_problems();

Returns a string describing the problems a grammar had in the precomputation phase.
For many precomputation problems, Marpa
does not immediately throw an exception.
This is because there are often several problems with a grammar.
Throwing an exception on the first problem would
force the user to fix them one at a time -- very tedious.
If there were no problems, returns a string saying so.

This method is not useful before precomputation.
An exception is thrown
when the user attempts to compile,
or to create a parse from,
a grammar with problems.
The string returned by C<show_problems> will be part of the exception's
error message.

=head3 show_productive_symbols

    $grammar = new Parse::Marpa::Grammar( { mdl_source => \$grammar_source } );
    $grammar->precompute();
    say "Productive symbols: ", $grammar->show_productive_symbols();

Returns a one-line string with the plumbing names
of the productive symbols of the grammar,
space-separated.
Useful in test scripts.
Not useful before the grammar is precomputed.
Not very useful for debugging.

=head3 show_rules

    $grammar = new Parse::Marpa::Grammar( { mdl_source => \$grammar_source } );
    print $grammar->show_rules();

Returns a string listing the rules, each commented as to whether it
was nullable, nulling, unproductive, inaccessible, empty or not useful.
If a rule had a non-zero priority, that is also shown.
Often useful and much of the information requires no knowledge of
the Marpa internals to interpret.

C<show_rules> shows a rule as not useful ("C<!useful>")
if it decides not to use it
for any reason.
Rules marked "C<!useful>" include not just the ones called useless in
standard parsing terminology (inaccessible and unproductive rules)
but also any rule which is replaced by one of Marpa's grammar rewrites.

=head3 show_symbols

    $grammar = new Parse::Marpa::Grammar( { mdl_source => \$grammar_source } );
    print $grammar->show_symbols();

Returns a string listing the symbols, along with whether they were
nulling, nullable, unproductive or inaccessible.
Also shown is a list of rules with that symbol on the left hand side,
and a list of rules which have that symbol anywhere on the right hand side.
Often useful and much of the information requires no knowledge of
the Marpa internals to interpret.

=head3 unproductive_symbols

    $grammar = new Parse::Marpa::Grammar( { mdl_source => \$grammar_source } );
    $grammar->precompute();
    if ($unproductive_symbols) {
       for my $symbol (@{$grammar->unproductive_symbols()}) {
	   say "Unproductive symbol: ", $symbol;
       }
    }

Given a precomputed grammar, returns the
plumbing names of the
unproductive symbols.
Not useful before the grammar is precomputed.
Used in test scripts.
For debugging and tracing,
the warnings option is usually the most convenient
way to obtain the same information.

=head2 Recognizer Method

=head3 show_status

    my $recce = new Parse::Marpa::Recognizer( { grammar => $grammar } );
    my $fail_location = $recce->text(\$text_to_parse);
    print $recce->show_status();
    if ($fail_location >= 0) {
        print STDERR Parse::Marpa::show_location("Parse failed", \$text_to_parse, $fail_location);
        exit 1;
    }

This is the central tool for debugging a parse
using Marpa internals.
Returns a multi-line string
listing every Earley item in every Earley set.
For each Earley item,
any current successor, predecessor, effect, cause, pointer or value is shown.
Also shown are lists of all the links and rules in each Earley item,
indicating which link or rule is the current choice.

=head2 Evaluator Method

=head3 show

    my $evaler = new Parse::Marpa::Evaluator($recce);
    croak("Input not recognized by grammar") unless $evaler;
    print $evaler->show();

If the evaluator has a value
the C<show> method returns the parse derivation used to produce that value.
Evaluators have values after successful calls of their C<next> method.
If the evaluator is unvalued, an exception is thrown.

Very useful.  Basic use requires no Marpa internals.
For those who are delving into the internals,
the corresponding Earley item and SDFA state are reported
with each line of the derivation.

=head1 SUPPORT

See the L<support section|Parse::Marpa/SUPPORT> in the main module.

=head1 AUTHOR

Jeffrey Kegler

=head1 COPYRIGHT

Copyright 2007 - 2008 Jeffrey Kegler

This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.

=cut

